//! # Error Reporting Combinators
//!
//! This module provides a suite of combinators focused on advanced error reporting for parsers.
//! The primary value in this module comes from [`CheckError`] and [`ImproveError`], which allow you to
//! transform and enhance error messages generated by your parsers—making it easier to diagnose failures.
//!
//! The remaining combinators in this module (such as [`ParseReport`], [`ParseReportAll`],
//! [`ParseMismatch`], and [`ParseForbiden`]) serve as the underlying building blocks. They invert
//! parser outcomes (e.g. turning successes into failures) or tag errors with additional context (e.g. marking
//! forbidden constructs or mismatches).
//!
//! **NOTE:** When using combinators that catch recursive errors (for instance, [`ParseReportAll`] or [`ImproveError`]),
//! be cautious: if the child parser calls the parent recursively, you risk infinite loops.
//! In such cases, wrapping these combinators in a caching combinator (such as [`CachedComb`]) with a dedicated cache key
//! is strongly recommended.
//!
//! [`CachedComb`]: crate::cache::CachedComb

use crate::combinator::CombinatorExt;
use std::marker::PhantomData;
use crate::combinator::{Combinator, Parsable, Pakerat, PakeratError};
use crate::core::{Input, Expected, Found, Mismatch, ParseError};
use crate::cache::DynCache;

/// Catches the error of another parser.
///
/// This combinator is meant for diagnostic purposes: when used, it catches a non-recursive error from the inner parser
/// (if one occurs) and returns it as a successful result: reporting what the error would have been without consuming any input.
/// Conversely, if the inner parser succeeds, it returns a failure (`ParseError::Empty`).
///
/// **IMPORTANT: Recursive errors are escalated unchanged as an error.** This behavior is crucial to prevent infinite loops
/// in recursive parsing contexts. If this is not desired use [`ParseReportAll`] instead.
///
/// This parser acts as a bridge between regular parsers and the error-style parsers found in the [`reporting`] module.
///
///[`reporting`]: crate::reporting
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, ParseError};
/// use pakerat_combinators::reporting::ParseReport;
/// use syn::buffer::TokenBuffer;
///
/// fn main() {
///     let tokens = "2 dummy".parse().unwrap();
///     let buffer = TokenBuffer::new2(tokens);
///     let input = Input::new(&buffer);
///     let mut cache = BasicCache::<0>::new();
///
///     let reporter = ParseReport::new(IdentParser);
///
///     // If IdentParser succeeds (i.e. "dummy" is an identifier),
///     // the inverse parser returns an error.
///     match reporter.parse(input, &mut cache) {
///         Ok((_input, err)) => {
///             println!("Inner parser did not match as expected. Error: {:?}", err);
///         },
///         Err(e) => {
///             panic!("Unexpected match: {:?}", e);
///         }
///     }
/// }
/// ```
pub struct ParseReport<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseReport<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER) -> Self {
        Self {
            inner,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<ParseError, O> for ParseReport<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, ParseError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok(_) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(PakeratError::Regular(e)) => Ok((input,e)),
            Err(PakeratError::Recursive(e)) => Err(PakeratError::Recursive(e)),
        }
    }
}

/// Catches the error of another parser (including recursive ones).
///
/// This combinator is meant for diagnostic purposes: when used, it catches errors from its inner parser—both
/// non‑recursive and recursive—returning them as a successful result that reports what the error would have been
/// without consuming any input. Conversely, if the inner parser succeeds (i.e. produces no error), it returns a
/// failure (`ParseError::Empty`).
///
/// **WARNING:** If you intend to allow the child to call this combinator (i.e. if the child parser contains the parent
/// in its recursive definitions), it is **highly recommended** to wrap a `ParseReportAll` instance in a caching
/// combinator (such as [`CachedComb`]) with a dedicated cache key. In cases where the child never calls the parent,
/// such wrapping is not necessary. However, when the child does invoke this combinator, failure to cache may result in
/// non‑linear or infinite parse times.
///
/// In most cases, [`ParseReport`]—which only catches non‑recursive errors—is the superior diagnostic option.
/// Use `ParseReportAll` only when you explicitly need to report recursive errors as well.
///
/// [`CachedComb`]: crate::cache::CachedComb
/// [`ParseReport`]: crate::reporting::ParseReport
///
/// # Example
///
/// ```rust
/// use pakerat_combinators::combinator::{Combinator,PakeratError};
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::{CachedComb, BasicCache};
/// use pakerat_combinators::core::{Input,};
/// use pakerat_combinators::reporting::ParseReportAll;
/// use syn::buffer::TokenBuffer;
///
/// fn main() {
///     // Our base parser is an identifier parser.
///     let base_parser = IdentParser;
///     
///     // Wrap the base parser in ParseReportAll to catch both non‑recursive and recursive errors.
///     let report_all = ParseReportAll::new(base_parser);
///     
///     // If your inner parser (the child) might call this combinator recursively,
///     // it is highly recommended to wrap the report_all parser in a caching combinator with a dedicated cache key.
///     let reporting_parser = CachedComb::new(report_all, 0, "infinite loop bug");
///     
///     let tokens = "dummy".parse().unwrap();
///     let buffer = TokenBuffer::new2(tokens);
///     let input = Input::new(&buffer);
///     
///     // Ensure that the cache is sized sufficiently (here, 1 is used because key 0 is accessed).
///     let mut cache = BasicCache::<1, PakeratError>::new();
///     
///     // Use the reporting parser. If the inner parser succeeds (i.e. no error occurs), then
///     // ParseReportAll returns a failure. Otherwise, it reports the error (whether non‑recursive or recursive).
///     match reporting_parser.parse(input, &mut cache) {
///         Ok((_remaining, error)) => {
///             println!("Reported error: {:?}", error);
///         },
///         Err(e) => {
///             println!("Unexpected success (inner parser matched): {:?}", e);
///         }
///     }
/// }
/// ```
pub struct ParseReportAll<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseReportAll<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER) -> Self {
        Self {
            inner,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<PakeratError, O> for ParseReportAll<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, PakeratError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok(_) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(e)=> Ok((input, e)),
        }
    }
}

/// A parser that reports a mismatch error when the inner parser succeeds.
///
/// This is useful for detecting unexpected matches.  
/// If the inner parser finds a match, this parser returns `Ok(ParseError::Simple(Mismatch))`,  
/// reporting that the found token (only the first token is used) does not match the expected pattern.  
/// If the inner parser fails normally, this parser returns `Err(ParseError::Empty)`.  
/// Recursive errors from the inner parser are escalated unchanged.
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, Expected};
/// use pakerat_combinators::reporting::ParseMismatch;
/// use syn::buffer::TokenBuffer;
///
/// let tokens = "dummy".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
///
/// let mismatcher = ParseMismatch::new(IdentParser, Expected::Text("a literal"));
/// let _ = mismatcher.parse(input, &mut cache);
/// ```
pub struct ParseMismatch<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub expected: Expected,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseMismatch<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER, expected: Expected) -> Self {
        Self {
            inner,
            expected,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<ParseError, O> for ParseMismatch<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, ParseError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok((next, recognized)) => {
                let mismatch = Mismatch {
                    actual: Found::start_of(recognized),
                    expected: self.expected.clone(),
                };
                Ok((next, ParseError::Simple(mismatch)))
            }
            Err(PakeratError::Regular(_)) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(PakeratError::Recursive(e)) => Err(PakeratError::Recursive(e)),
        }
    }
}

/// A parser that reports a forbidden construct when the inner parser succeeds.
///
/// If the inner parser matches, this parser returns `Ok(ParseError::Message)`,  
/// tagging the recognized input with a custom error message.  
/// If the inner parser fails normally, this parser returns `Err(ParseError::Empty)`.  
/// Recursive errors from the inner parser are escalated unchanged.
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::Input;
/// use pakerat_combinators::reporting::ParseForbiden;
/// use syn::buffer::TokenBuffer;
///
/// let tokens = "dummy".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
///
/// let forbidden = ParseForbiden::new(IdentParser, "forbidden identifier usage");
/// let _ = forbidden.parse(input, &mut cache);
/// ```
pub struct ParseForbiden<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub message: &'static str,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseForbiden<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER, message: &'static str) -> Self {
        Self {
            inner,
            message,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<ParseError, O> for ParseForbiden<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, ParseError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok((next, recognized)) => {
                Ok((next, ParseError::Message(recognized.span(), self.message)))
            }
            Err(PakeratError::Regular(_)) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(PakeratError::Recursive(e)) => Err(PakeratError::Recursive(e)),
        }
    }
}

/// A combinator that aggregates multiple errors into a single [`ParseError::Multi`] variant.
///
/// This is useful when a parser can produce multiple distinct errors, and you want to collect
/// all of them rather than failing on the first one encountered. It allows you to provide
/// more comprehensive error messages by returning a list of errors rather than a single failure.
///
/// This combinator expects its inner parser to return `Vec<ParseError>` if this is an issue just call map instead.
///
/// # Example
///
/// ```rust
/// use pakerat_combinators::combinator::{Combinator,CombinatorExt, PakeratError};
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, ParseError};
/// use pakerat_combinators::reporting::{MultiError,ParseReport};
/// use pakerat_combinators::basic_parsers::{IdentParser,AnyParser};
/// use pakerat_combinators::multi::{Many1,Skip,Pair};
/// use syn::buffer::TokenBuffer;
///
/// let tokens = "1 &".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
/// 
/// //find all non idents
/// let error_aggregator = MultiError::new(
///     Many1::new(
///         Pair::new(
///             ParseReport::new(IdentParser),
///             AnyParser
///         ).map(|(a, _)| a)
///     )
/// );
/// let (_,error) = error_aggregator.parse(input,&mut cache).unwrap();
/// assert!(matches!(error,ParseError::Multi(v)));
/// ```
///
pub struct MultiError<INNER,O> 
where INNER:Combinator<Vec<ParseError>,O>,O:Parsable
{
    pub inner: INNER,
    pub _phantom: PhantomData<O>,
}

impl<INNER,O> Combinator<ParseError,O> for MultiError<INNER,O>
where INNER:Combinator<Vec<ParseError>,O>,O:Parsable{
fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>,ParseError)> {
        let (next,vec) = self.inner.parse(input,cache)?;
        Ok((next,ParseError::Multi(vec.into())))
    }
fn parse_ignore<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<Input<'a>> {
        self.inner.parse_ignore(input,cache)
}
}




impl<INNER,O> MultiError<INNER,O> 
where INNER:Combinator<Vec<ParseError>,O>,O:Parsable
{
    pub fn new(inner:INNER) -> Self{
        Self{inner,_phantom:PhantomData}
    }
}

/// Inverted parser that raises errors on inner successes.
///
/// If the inner parser returns `Ok((_, err))`, its error is raised as a failure.
/// If it returns a regular error the parser succeeds returning the input.
///
/// This parser is useful as a way to validate inputs. The returned error can be customized, which is the main benefit.
/// Try using with [`Wrapped`] as a way to validate inputs. 
///
/// [`Wrapped`]: crate::multi::Wrapped
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::{PakeratError,Combinator};
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, Expected, ParseError};
/// use pakerat_combinators::reporting::{ParseMismatch, CheckError};
/// use syn::buffer::TokenBuffer;
/// use std::marker::PhantomData;
///
/// let tokens = "identifier".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
///
/// // Create a parser that expects a literal but finds an identifier.
/// let mismatcher = ParseMismatch::new(IdentParser, Expected::Text("a literal"));
///
/// // Wrap it in CheckError to turn the mismatch into a raised error.
/// let raise = CheckError {
///     inner: mismatcher,
///     _phantom: PhantomData,
/// };
///
/// let result = raise.parse(input, &mut cache);
///
/// // Since the input is an identifier, ParseMismatch will succeed with an error,
/// // which CheckError should then raise.
/// assert!(matches!(result, Err(PakeratError::Regular(ParseError::Simple(_)))));
/// ```
pub struct CheckError<INNER,O> 
where INNER:Combinator<ParseError,O>,O:Parsable
{
    pub inner: INNER,
    pub _phantom: PhantomData<O>,
}

impl<INNER,O> Combinator<(),O> for CheckError<INNER,O>
where INNER:Combinator<ParseError,O>,O:Parsable{
fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>,())> {
    match self.inner.parse(input,cache) {
        Ok((_,err)) => Err(PakeratError::Regular(err)),
        Err(PakeratError::Regular(_)) => Ok((input,())),
        Err(e)=> Err(e),
    }

}
}

impl<INNER,O> CheckError<INNER,O> 
where INNER:Combinator<ParseError,O>,O:Parsable
{
    pub fn new(inner:INNER) -> Self{
        Self{inner,_phantom:PhantomData}
    }
}

/// Improves the error of its inner parser by running an alternative error parser when the inner parser fails.
///
/// The improved error preserves the original error's variant.  
/// **WARNING:** Catching recursive errors this way can lead to infinite loops if used recursively; see
/// [`ParseReportAll`] for details.
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::{IntParser, IdentParser};
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, ParseError};
/// use pakerat_combinators::reporting::{ImproveError, ParseForbiden};
/// use pakerat_combinators::combinator::PakeratError;
/// use syn::buffer::TokenBuffer;
///
/// let error_parser = ParseForbiden::new(IntParser, "forbidden integer usage");
/// let improved = ImproveError::new(IdentParser, error_parser);
///
/// // Create a cache with at least one slot (key 0 is used).
/// let mut cache = BasicCache::<1, PakeratError>::new();
///
/// // Case 1: Input "123" (a number)
/// // - IdentParser fails because "123" is not an identifier.
/// // - ParseForbiden matches "123" as an integer and reports "forbidden integer usage."
/// let tokens = "123".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
///
/// match improved.parse(input, &mut cache) {
///     Ok((_, value)) => println!("Unexpected success: {:?}", value),
///     Err(e) => println!("Input: \"123\" | Improved error: {:?}", e),
/// }
///
/// // Case 2: Input ";" (neither an identifier nor an integer)
/// // - IdentParser fails because ";" is not an identifier.
/// // - ParseForbiden also fails because ";" is not an integer.
/// // - Since the error parser fails, the original IdentParser error is returned.
/// let tokens = ";".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
///
/// match improved.parse(input, &mut cache) {
///     Ok((_, value)) => println!("Unexpected success: {:?}", value),
///     Err(e) => println!("Input: \";\" | Improved error: {:?}", e),
/// }
/// ```

pub struct ImproveError<INNER, ERR, T = (), O = T>
where
    INNER: Combinator<T, O>,
    ERR: Combinator<ParseError, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub error_parser: ERR,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, ERR, T, O> ImproveError<INNER, ERR, T, O>
where
    INNER: Combinator<T, O>,
    ERR: Combinator<ParseError, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER, error_parser: ERR) -> Self {
        Self {
            inner,
            error_parser,
            _phantom: PhantomData,
        }
    }
    
    fn make_err<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
        orig: PakeratError,
    ) -> PakeratError {
        match self.error_parser.parse(input, cache) {
            Ok((_i, improved)) => match orig {
                PakeratError::Regular(_) => PakeratError::Regular(improved),
                PakeratError::Recursive(_) => PakeratError::Recursive(improved),
            },
            Err(_) => orig,
        }
    }
}

impl<INNER, ERR, T, O> Combinator<T, O> for ImproveError<INNER, ERR, T, O>
where
    INNER: Combinator<T, O>,
    ERR: Combinator<ParseError, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, T::Output<'a>)> {
        match self.inner.parse(input, cache) {
            Ok(good) => Ok(good),
            Err(orig) => Err(self.make_err(input, cache, orig)),
        }
    }
    
    fn parse_ignore<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<Input<'a>> {
        match self.inner.parse_ignore(input, cache) {
            Ok(good) => Ok(good),
            Err(orig) => Err(self.make_err(input, cache, orig)),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::multi::OrLast;
use crate::cache::DebugCache;
use crate::multi::DebugComb;
use crate::reporting::Pakerat;
use crate::reporting::DynCache;
use crate::reporting::CheckError;
use crate::combinator::Combinator;
use crate::basic_parsers::{IntParser, SpecificPunct, Nothing};
    use crate::cache::{BasicCache, CachedComb};
    use crate::combinator::{CombinatorExt, PakeratError};
    use crate::multi::{Ignore, Pair, Skip, Recognize};
    use crate::one_of_last;
    use crate::recursive::OwnedRecursiveParser;
    use crate::reporting::{Mismatch, ParseError};
    use crate::reporting::Found;
    use crate::reporting::Expected;
    use crate::core::Input;
    use syn::buffer::TokenBuffer;

    #[test]
    fn plus_test() {

        // --- Build the valid arithmetic parser ---
        // This parser supports addition with the grammar:
        //     expr = int | int '+' expr
        // It is built recursively using an OwnedRecursiveParser.
        let basic_num = DebugComb::new("basic_num",OwnedRecursiveParser::new()).leak();
        basic_num.inner.inner.set(
            // DebugComb::new("cache",CachedComb::new(
               DebugComb::new("or",OrLast::new(
                    // Pattern: int '+' expr  => compute lhs + rhs
                    DebugComb::new("map",
                    DebugComb::new("pair",Pair::new(
                        DebugComb::new("left int",IntParser),
                        DebugComb::new("+ int",
                            Pair::new(
                                DebugComb::new("+",SpecificPunct('+')), 
                                DebugComb::new("right recurse",basic_num))
                            )
                    ))
                    .map(|(lhs, (_, rhs))| lhs + rhs)
                    ),
                    // Pattern: int alone
                     DebugComb::new("fallback",IntParser)
                // )),
                // 0,
                // "infinite loop in basic_num"
            ))
        );

        // --- Build an error-checker for the pattern "int +"
        // This catches the case where an expression is followed by a '+' with no integer afterwards.
        let missing_right = Skip::new(
            Ignore::new(
                Pair::new(
                    Ignore::new(basic_num),
                    Ignore::new(SpecificPunct('+'))
                )
            ),
            Recognize::new(Nothing)
        )
            .map(|recognized_input| {
                ParseError::Simple(
                    Mismatch {
                        actual: Found::start_of(recognized_input),
                        expected: Expected::Text("an int")
                    }
                )
            });

        // --- Combine valid parsing with error reporting ---
        // If the valid parser (basic_num) fails, missing_right is run to produce a more detailed error.
        let unified_parser = Skip::new(CheckError::new(missing_right),basic_num);

        // Create a cache for integer results. The cache key here is 1.
        let mut cache = BasicCache::<1, i64>::new();

        // --- Run a valid example ---
        let tokens_valid = "1+2+3".parse().expect("Tokenization failed");
        let buffer_valid = TokenBuffer::new2(tokens_valid);
        let input_valid = Input::new(&buffer_valid);
        let (remaining_valid, result) = unified_parser.parse(input_valid, &mut cache)
            .expect("Valid input should parse");
        // Ensure that all tokens are consumed and the result is as expected.
        assert!(remaining_valid.eof());
        assert_eq!(result, 1 + 2 + 3);

        // --- Run an invalid example: "1+" ---
        let mut cache = DebugCache::new(BasicCache::<1, i64>::new());

        let tokens_invalid = "1+".parse().expect("Tokenization failed");
        let buffer_invalid = TokenBuffer::new2(tokens_invalid);
        let input_invalid = Input::new(&buffer_invalid);
        let err = unified_parser.parse(input_invalid, &mut cache);

        let err = err.map(|(x,_)| Found::start_of(x))
            .expect_err("Invalid input should produce an error");

        // Check that the error is a simple mismatch error reporting a missing integer.
        match err {
            PakeratError::Regular(ParseError::Simple(mismatch)) => {
                // Print out the found token (the offending '+' or its span) using its Display implementation.
                println!("Mismatch error found: actual: {}", mismatch.actual);
                // // Assert that the "found" text (converted to a string) contains the '+' character.
                // assert!(format!("{}", mismatch.actual).contains("+"),
                //         "Expected the found token to contain '+', got: {}", mismatch);
            },
            _ => panic!("Expected a simple mismatch error for missing integer after '+'"),
        }
    }
}
