//! # Error Reporting Combinators
//!
//! This module provides a suite of combinators focused on advanced error reporting for parsers.
//! The primary value in this module comes from [`CheckError`] and [`ImproveError`], which allow you to
//! transform and enhance error messages generated by your parsers.
//!
//! The remaining combinators in this module (such as [`ParseReport`], [`ParseMismatch`])
//! serve as the underlying building blocks.
//! They are sort of "inverted parsers" that return Ok(ParseError) when something should error and Err(Empty) when everything is fine.
//!
//! **NOTE:** When using combinators that catch recursive errors (for instance, [`ParseReportAll`] or [`ImproveError`]),
//! be cautious: if the child parser calls the parent recursively, you risk infinite loops.
//! In such cases, wrapping these combinators in a caching combinator (such as [`CachedComb`]) with a dedicated cache key
//! is strongly recommended.
//!
//! [`CachedComb`]: crate::cache::CachedComb
//!
//!
//!
//! # Example
//!
//! ```rust
//! use pakerat_combinators::combinator::{Combinator,CombinatorExt};
//! use pakerat_combinators::basic_parsers::{IntParser, SpecificPunct, Nothing};
//! use pakerat_combinators::cache::{BasicCache, CachedComb};
//! use pakerat_combinators::reporting::CheckError;
//! use pakerat_combinators::multi::{OrLast, Pair, Skip, Recognize,Ignore};
//! use pakerat_combinators::core::{Input,ParseError, Mismatch, Expected, Found};
//! use pakerat_combinators::recursive::OwnedRecursiveParser;
//! use syn::buffer::TokenBuffer;
//!
//! //basic addition parser
//! let mut basic_num = OwnedRecursiveParser::new().leak();
//! basic_num.set(
//!     OrLast::new(
//!         CachedComb::new(
//!             Pair::new(
//!                 IntParser,
//!                 Pair::new(SpecificPunct('+'), basic_num)
//!             ).map(|(lhs, (_, rhs))| lhs + rhs),
//!             0,
//!             "infinite loop in basic_num"
//!         ),
//!         IntParser
//!     )
//! );
//!
//! //check for 1+ style errors 
//! let missing_right = Skip::new(
//!     Ignore::new(Pair::new(
//!         basic_num,
//!         SpecificPunct('+')
//!     )),
//!     Recognize::new(Nothing)
//! ).map(|recognized_input| {
//!     ParseError::Simple(Mismatch {
//!         actual: Found::start_of(recognized_input),
//!         expected: Expected::Text("an int")
//!     })
//! });
//!
//! //integrate the 2 parsers
//! let unified_parser = Skip::new(CheckError::new(missing_right), basic_num);
//!
//! //--tests
//!
//! let mut cache = BasicCache::<1, i64>::new();
//!
//! let tokens_valid = "1+2+3".parse().unwrap();
//! let buffer_valid = TokenBuffer::new2(tokens_valid);
//! let input_valid = Input::new(&buffer_valid);
//! let (remaining_valid, result) = unified_parser.parse(input_valid, &mut cache).unwrap();
//! assert!(remaining_valid.eof());
//! assert_eq!(result, 6);
//!
//! let mut cache = BasicCache::<1, i64>::new();
//! let tokens_invalid = "1+".parse().unwrap();
//! let buffer_invalid = TokenBuffer::new2(tokens_invalid);
//! let input_invalid = Input::new(&buffer_invalid);
//! let err = unified_parser.parse(input_invalid, &mut cache)
//!             .map(|(x,_)| Found::start_of(x))
//!             .unwrap_err();
//!
//! if let pakerat_combinators::combinator::PakeratError::Regular(ParseError::Simple(mismatch)) = err {
//!     println!("Mismatch error: {}", mismatch.actual);
//! } else {
//!     panic!("Expected a mismatch error for missing integer after '+'");
//! }
//! ```


use crate::combinator::CombinatorExt;
use std::marker::PhantomData;
use crate::combinator::{Combinator, Parsable, Pakerat, PakeratError};
use crate::core::{Input, Expected, Found, Mismatch, ParseError};
use crate::cache::DynCache;

/// Catches the error of another parser.
///
/// This combinator is meant for diagnostic purposes: when used, it catches a non-recursive error from the inner parser
/// (if one occurs) and returns it as a successful result: reporting what the error would have been without consuming any input.
/// Conversely, if the inner parser succeeds, it returns a failure (`ParseError::Empty`).
///
/// **IMPORTANT: Recursive errors are escalated unchanged as an error.** This behavior is crucial to prevent infinite loops
/// in recursive parsing contexts. If this is not desired use [`ParseReportAll`] instead.
///
/// This parser acts as a bridge between regular parsers and the error-style parsers found in the [`reporting`] module.
///
///[`reporting`]: crate::reporting
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, ParseError};
/// use pakerat_combinators::reporting::ParseReport;
/// use syn::buffer::TokenBuffer;
///
/// fn main() {
///     let tokens = "2 dummy".parse().unwrap();
///     let buffer = TokenBuffer::new2(tokens);
///     let input = Input::new(&buffer);
///     let mut cache = BasicCache::<0>::new();
///
///     let reporter = ParseReport::new(IdentParser);
///
///     // If IdentParser succeeds (i.e. "dummy" is an identifier),
///     // the inverse parser returns an error.
///     match reporter.parse(input, &mut cache) {
///         Ok((_input, err)) => {
///             println!("Inner parser did not match as expected. Error: {:?}", err);
///         },
///         Err(e) => {
///             panic!("Unexpected match: {:?}", e);
///         }
///     }
/// }
/// ```
pub struct ParseReport<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseReport<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER) -> Self {
        Self {
            inner,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<ParseError, O> for ParseReport<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, ParseError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok(_) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(PakeratError::Regular(e)) => Ok((input,e)),
            Err(PakeratError::Recursive(e)) => Err(PakeratError::Recursive(e)),
        }
    }
}

/// Catches the error of another parser (including recursive ones).
///
/// This combinator is meant for diagnostic purposes: when used, it catches errors from its inner parser—both
/// non‑recursive and recursive—returning them as a successful result that reports what the error would have been
/// without consuming any input. Conversely, if the inner parser succeeds (i.e. produces no error), it returns a
/// failure (`ParseError::Empty`).
///
/// **WARNING:** If you intend to allow the child to call this combinator (i.e. if the child parser contains the parent
/// in its recursive definitions), it is **highly recommended** to wrap a `ParseReportAll` instance in a caching
/// combinator (such as [`CachedComb`]) with a dedicated cache key. In cases where the child never calls the parent,
/// such wrapping is not necessary. However, when the child does invoke this combinator, failure to cache may result in
/// non‑linear or infinite parse times.
///
/// In most cases, [`ParseReport`]—which only catches non‑recursive errors—is the superior diagnostic option.
/// Use `ParseReportAll` only when you explicitly need to report recursive errors as well.
///
/// [`CachedComb`]: crate::cache::CachedComb
/// [`ParseReport`]: crate::reporting::ParseReport
///
/// # Example
///
/// ```rust
/// use pakerat_combinators::combinator::{Combinator,PakeratError};
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::{CachedComb, BasicCache};
/// use pakerat_combinators::core::{Input,};
/// use pakerat_combinators::reporting::ParseReportAll;
/// use syn::buffer::TokenBuffer;
///
/// fn main() {
///     // Our base parser is an identifier parser.
///     let base_parser = IdentParser;
///     
///     // Wrap the base parser in ParseReportAll to catch both non‑recursive and recursive errors.
///     let report_all = ParseReportAll::new(base_parser);
///     
///     // If your inner parser (the child) might call this combinator recursively,
///     // it is highly recommended to wrap the report_all parser in a caching combinator with a dedicated cache key.
///     let reporting_parser = CachedComb::new(report_all, 0, "infinite loop bug");
///     
///     let tokens = "dummy".parse().unwrap();
///     let buffer = TokenBuffer::new2(tokens);
///     let input = Input::new(&buffer);
///     
///     // Ensure that the cache is sized sufficiently (here, 1 is used because key 0 is accessed).
///     let mut cache = BasicCache::<1, PakeratError>::new();
///     
///     // Use the reporting parser. If the inner parser succeeds (i.e. no error occurs), then
///     // ParseReportAll returns a failure. Otherwise, it reports the error (whether non‑recursive or recursive).
///     match reporting_parser.parse(input, &mut cache) {
///         Ok((_remaining, error)) => {
///             println!("Reported error: {:?}", error);
///         },
///         Err(e) => {
///             println!("Unexpected success (inner parser matched): {:?}", e);
///         }
///     }
/// }
/// ```
pub struct ParseReportAll<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseReportAll<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER) -> Self {
        Self {
            inner,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<PakeratError, O> for ParseReportAll<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, PakeratError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok(_) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(e)=> Ok((input, e)),
        }
    }
}

/// A parser that reports a mismatch error when the inner parser succeeds.
///
/// This is useful for detecting unexpected matches.  
/// If the inner parser finds a match, this parser returns `Ok(ParseError::Simple(Mismatch))`,  
/// reporting that the found token (only the first token is used) does not match the expected pattern.  
/// If the inner parser fails normally, this parser returns `Err(ParseError::Empty)`.  
/// Recursive errors from the inner parser are escalated unchanged.
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, Expected};
/// use pakerat_combinators::reporting::ParseMismatch;
/// use syn::buffer::TokenBuffer;
///
/// let tokens = "dummy".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
///
/// let mismatcher = ParseMismatch::new(IdentParser, Expected::Text("a literal"));
/// let _ = mismatcher.parse(input, &mut cache);
/// ```
pub struct ParseMismatch<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub expected: Expected,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseMismatch<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER, expected: Expected) -> Self {
        Self {
            inner,
            expected,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<ParseError, O> for ParseMismatch<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, ParseError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok((next, recognized)) => {
                let mismatch = Mismatch {
                    actual: Found::start_of(recognized),
                    expected: self.expected.clone(),
                };
                Ok((next, ParseError::Simple(mismatch)))
            }
            Err(PakeratError::Regular(_)) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(PakeratError::Recursive(e)) => Err(PakeratError::Recursive(e)),
        }
    }
}

/// A parser that reports a forbidden construct when the inner parser succeeds.
///
/// If the inner parser matches, this parser returns `Ok(ParseError::Message)`,  
/// tagging the recognized input with a custom error message.  
/// If the inner parser fails normally, this parser returns `Err(ParseError::Empty)`.  
/// Recursive errors from the inner parser are escalated unchanged.
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::Input;
/// use pakerat_combinators::reporting::ParseForbiden;
/// use syn::buffer::TokenBuffer;
///
/// let tokens = "dummy".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
///
/// let forbidden = ParseForbiden::new(IdentParser, "forbidden identifier usage");
/// let _ = forbidden.parse(input, &mut cache);
/// ```
pub struct ParseForbiden<INNER, T = (), O = T>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub message: &'static str,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, T, O> ParseForbiden<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER, message: &'static str) -> Self {
        Self {
            inner,
            message,
            _phantom: PhantomData,
        }
    }
}

impl<INNER, T, O> Combinator<ParseError, O> for ParseForbiden<INNER, T, O>
where
    INNER: Combinator<T, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, ParseError)> {
        match self.inner.parse_recognize(input, cache) {
            Ok((next, recognized)) => {
                Ok((next, ParseError::Message(recognized.span(), self.message)))
            }
            Err(PakeratError::Regular(_)) => Err(PakeratError::Regular(ParseError::Empty)),
            Err(PakeratError::Recursive(e)) => Err(PakeratError::Recursive(e)),
        }
    }
}

/// A combinator that aggregates multiple errors into a single [`ParseError::Multi`] variant.
///
/// This is useful when a parser can produce multiple distinct errors, and you want to collect
/// all of them rather than failing on the first one encountered. It allows you to provide
/// more comprehensive error messages by returning a list of errors rather than a single failure.
///
/// This combinator expects its inner parser to return `Vec<ParseError>` if this is an issue just call map instead.
///
/// # Example
///
/// ```rust
/// use pakerat_combinators::combinator::{Combinator,CombinatorExt, PakeratError};
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, ParseError};
/// use pakerat_combinators::reporting::{MultiError,ParseReport};
/// use pakerat_combinators::basic_parsers::{IdentParser,AnyParser};
/// use pakerat_combinators::multi::{Many1,Skip,Pair};
/// use syn::buffer::TokenBuffer;
///
/// let tokens = "1 &".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
/// 
/// //find all non idents
/// let error_aggregator = MultiError::new(
///     Many1::new(
///         Pair::new(
///             ParseReport::new(IdentParser),
///             AnyParser
///         ).map(|(a, _)| a)
///     )
/// );
/// let (_,error) = error_aggregator.parse(input,&mut cache).unwrap();
/// assert!(matches!(error,ParseError::Multi(v)));
/// ```
///
pub struct MultiError<INNER,O> 
where INNER:Combinator<Vec<ParseError>,O>,O:Parsable
{
    pub inner: INNER,
    pub _phantom: PhantomData<O>,
}

impl<INNER,O> Combinator<ParseError,O> for MultiError<INNER,O>
where INNER:Combinator<Vec<ParseError>,O>,O:Parsable{
fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>,ParseError)> {
        let (next,vec) = self.inner.parse(input,cache)?;
        Ok((next,ParseError::Multi(vec.into())))
    }
fn parse_ignore<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<Input<'a>> {
        self.inner.parse_ignore(input,cache)
}
}




impl<INNER,O> MultiError<INNER,O> 
where INNER:Combinator<Vec<ParseError>,O>,O:Parsable
{
    pub fn new(inner:INNER) -> Self{
        Self{inner,_phantom:PhantomData}
    }
}

/// Inverted parser that raises errors on inner successes.
///
/// If the inner parser returns `Ok((_, err))`, its error is raised as a failure.
/// If it returns a regular error the parser succeeds returning the input.
///
/// This parser is useful as a way to validate inputs. The returned error can be customized, which is the main benefit.
/// Try using with [`Wrapped`] as a way to validate inputs. 
///
/// [`Wrapped`]: crate::multi::Wrapped
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::{PakeratError,Combinator};
/// use pakerat_combinators::basic_parsers::IdentParser;
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, Expected, ParseError};
/// use pakerat_combinators::reporting::{ParseMismatch, CheckError};
/// use syn::buffer::TokenBuffer;
/// use std::marker::PhantomData;
///
/// let tokens = "identifier".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
/// let mut cache = BasicCache::<0>::new();
///
/// // Create a parser that expects a literal but finds an identifier.
/// let mismatcher = ParseMismatch::new(IdentParser, Expected::Text("a literal"));
///
/// // Wrap it in CheckError to turn the mismatch into a raised error.
/// let raise = CheckError {
///     inner: mismatcher,
///     _phantom: PhantomData,
/// };
///
/// let result = raise.parse(input, &mut cache);
///
/// // Since the input is an identifier, ParseMismatch will succeed with an error,
/// // which CheckError should then raise.
/// assert!(matches!(result, Err(PakeratError::Regular(ParseError::Simple(_)))));
/// ```
pub struct CheckError<INNER,O> 
where INNER:Combinator<ParseError,O>,O:Parsable
{
    pub inner: INNER,
    pub _phantom: PhantomData<O>,
}

impl<INNER,O> Combinator<(),O> for CheckError<INNER,O>
where INNER:Combinator<ParseError,O>,O:Parsable{
fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>,())> {
    match self.inner.parse(input,cache) {
        Ok((_,err)) => Err(PakeratError::Regular(err)),
        Err(PakeratError::Regular(_)) => Ok((input,())),
        Err(e)=> Err(e),
    }

}
}

impl<INNER,O> CheckError<INNER,O> 
where INNER:Combinator<ParseError,O>,O:Parsable
{
    pub fn new(inner:INNER) -> Self{
        Self{inner,_phantom:PhantomData}
    }
}

/// Improves the error of its inner parser by running an alternative error parser when the inner parser fails.
///
/// The improved error preserves the original error's variant.  
/// **WARNING:** Catching recursive errors this way can lead to infinite loops if used recursively; see
/// [`ParseReportAll`] for details.
///
/// # Example
/// ```rust
/// use pakerat_combinators::combinator::Combinator;
/// use pakerat_combinators::basic_parsers::{IntParser, IdentParser};
/// use pakerat_combinators::cache::BasicCache;
/// use pakerat_combinators::core::{Input, ParseError};
/// use pakerat_combinators::reporting::{ImproveError, ParseForbiden};
/// use pakerat_combinators::combinator::PakeratError;
/// use syn::buffer::TokenBuffer;
///
/// let error_parser = ParseForbiden::new(IntParser, "forbidden integer usage");
/// let improved = ImproveError::new(IdentParser, error_parser);
///
/// // Create a cache with at least one slot (key 0 is used).
/// let mut cache = BasicCache::<1, PakeratError>::new();
///
/// // Case 1: Input "123" (a number)
/// // - IdentParser fails because "123" is not an identifier.
/// // - ParseForbiden matches "123" as an integer and reports "forbidden integer usage."
/// let tokens = "123".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
///
/// match improved.parse(input, &mut cache) {
///     Ok((_, value)) => println!("Unexpected success: {:?}", value),
///     Err(e) => println!("Input: \"123\" | Improved error: {:?}", e),
/// }
///
/// // Case 2: Input ";" (neither an identifier nor an integer)
/// // - IdentParser fails because ";" is not an identifier.
/// // - ParseForbiden also fails because ";" is not an integer.
/// // - Since the error parser fails, the original IdentParser error is returned.
/// let tokens = ";".parse().unwrap();
/// let buffer = TokenBuffer::new2(tokens);
/// let input = Input::new(&buffer);
///
/// match improved.parse(input, &mut cache) {
///     Ok((_, value)) => println!("Unexpected success: {:?}", value),
///     Err(e) => println!("Input: \";\" | Improved error: {:?}", e),
/// }
/// ```

pub struct ImproveError<INNER, ERR, T = (), O = T>
where
    INNER: Combinator<T, O>,
    ERR: Combinator<ParseError, O>,
    T: Parsable,
    O: Parsable,
{
    pub inner: INNER,
    pub error_parser: ERR,
    pub _phantom: PhantomData<(T, O)>,
}

impl<INNER, ERR, T, O> ImproveError<INNER, ERR, T, O>
where
    INNER: Combinator<T, O>,
    ERR: Combinator<ParseError, O>,
    T: Parsable,
    O: Parsable,
{
    pub fn new(inner: INNER, error_parser: ERR) -> Self {
        Self {
            inner,
            error_parser,
            _phantom: PhantomData,
        }
    }
    
    fn make_err<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
        orig: PakeratError,
    ) -> PakeratError {
        match self.error_parser.parse(input, cache) {
            Ok((_i, improved)) => match orig {
                PakeratError::Regular(_) => PakeratError::Regular(improved),
                PakeratError::Recursive(_) => PakeratError::Recursive(improved),
            },
            Err(_) => orig,
        }
    }
}

impl<INNER, ERR, T, O> Combinator<T, O> for ImproveError<INNER, ERR, T, O>
where
    INNER: Combinator<T, O>,
    ERR: Combinator<ParseError, O>,
    T: Parsable,
    O: Parsable,
{
    fn parse<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<(Input<'a>, T::Output<'a>)> {
        match self.inner.parse(input, cache) {
            Ok(good) => Ok(good),
            Err(orig) => Err(self.make_err(input, cache, orig)),
        }
    }
    
    fn parse_ignore<'a>(
        &self,
        input: Input<'a>,
        cache: &mut dyn DynCache<'a, O>,
    ) -> Pakerat<Input<'a>> {
        match self.inner.parse_ignore(input, cache) {
            Ok(good) => Ok(good),
            Err(orig) => Err(self.make_err(input, cache, orig)),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::multi::OrLast;
use crate::cache::DebugCache;
use crate::multi::DebugComb;
use crate::reporting::CheckError;
use crate::combinator::Combinator;
use crate::basic_parsers::{IntParser, SpecificPunct, Nothing};
    use crate::cache::{BasicCache, CachedComb};
    use crate::combinator::{CombinatorExt, PakeratError};
    use crate::multi::{Ignore, Pair, Skip, Recognize};
    
    use crate::recursive::OwnedRecursiveParser;
    use crate::reporting::{Mismatch, ParseError};
    use crate::reporting::Found;
    use crate::reporting::Expected;
    use crate::core::Input;
    use syn::buffer::TokenBuffer;

    #[test]
    fn plus_test() {

        // --- Build the valid arithmetic parser ---
        // This parser supports addition with the grammar:
        //     expr = int | int '+' expr
        // It is built recursively using an OwnedRecursiveParser.
        let basic_num = DebugComb::new("basic_num", OwnedRecursiveParser::new()).leak();
        basic_num.inner.inner.set(
            DebugComb::new("or", OrLast::new(
                // Pattern: int '+' expr  => compute lhs + rhs
                DebugComb::new("cache",
                    CachedComb::new(
                        DebugComb::new("map",
                            DebugComb::new("pair", Pair::new(
                                DebugComb::new("left int", IntParser),
                                DebugComb::new("+ int", 
                                    Pair::new(
                                        DebugComb::new("+", SpecificPunct('+')), 
                                        DebugComb::new("right recurse", basic_num)
                                    )
                                )
                            ))
                            .map(|(lhs, (_, rhs))| lhs + rhs)
                        ),
                        0, // Cache only the recursive branch
                        "infinite loop in basic_num"
                    )
                ),
                // Pattern: int alone (DO NOT CACHE)
                DebugComb::new("fallback", IntParser)
            ))
        );


        // --- Build an error-checker for the pattern "int +"
        // This catches the case where an expression is followed by a '+' with no integer afterwards.
        let missing_right = Skip::new(
            Ignore::new(
                Pair::new(
                    Ignore::new(basic_num),
                    Ignore::new(SpecificPunct('+'))
                )
            ),
            Recognize::new(Nothing)
        )
            .map(|recognized_input| {
                ParseError::Simple(
                    Mismatch {
                        actual: Found::start_of(recognized_input),
                        expected: Expected::Text("an int")
                    }
                )
            });

        // --- Combine valid parsing with error reporting ---
        // If the valid parser (basic_num) fails, missing_right is run to produce a more detailed error.
        let unified_parser = Skip::new(CheckError::new(missing_right),basic_num);

        // Create a cache for integer results. The cache key here is 1.
        let mut cache = BasicCache::<1, i64>::new();

        // --- Run a valid example ---
        let tokens_valid = "1+2+3".parse().expect("Tokenization failed");
        let buffer_valid = TokenBuffer::new2(tokens_valid);
        let input_valid = Input::new(&buffer_valid);
        let (remaining_valid, result) = unified_parser.parse(input_valid, &mut cache)
            .expect("Valid input should parse");
        // Ensure that all tokens are consumed and the result is as expected.
        assert!(remaining_valid.eof());
        assert_eq!(result, 1 + 2 + 3);

        // --- Run an invalid example: "1+" ---
        let mut cache = DebugCache::new(BasicCache::<1, i64>::new());

        let tokens_invalid = "1+".parse().expect("Tokenization failed");
        let buffer_invalid = TokenBuffer::new2(tokens_invalid);
        let input_invalid = Input::new(&buffer_invalid);
        let err = unified_parser.parse(input_invalid, &mut cache);

        let err = err.map(|(x,_)| Found::start_of(x))
            .expect_err("Invalid input should produce an error");

        // Check that the error is a simple mismatch error reporting a missing integer.
        match err {
            PakeratError::Regular(ParseError::Simple(mismatch)) => {
                // Print out the found token (the offending '+' or its span) using its Display implementation.
                println!("Mismatch error found: actual: {}", mismatch.actual);
                // // Assert that the "found" text (converted to a string) contains the '+' character.
                // assert!(format!("{}", mismatch.actual).contains("+"),
                //         "Expected the found token to contain '+', got: {}", mismatch);
            },
            _ => panic!("Expected a simple mismatch error for missing integer after '+'"),
        }
    }
}

#[cfg(test)]
mod bugged_code {
    use crate::multi::SkipToEnd;
use std::rc::Rc;
    use crate::basic_parsers::{IdentParser, IntParser, SpecificPunct, IsEOF, AnyParser};
    use crate::cache::{BasicCache, CachedComb};
    use crate::combinator::{Combinator, CombinatorExt, PakeratError};
    use crate::core::Input;
    use crate::multi::{Maybe, Pair, Ignore, Many1, SkipTo};
    use crate::reporting::{ImproveError, MultiError, ParseForbiden, ParseReport, Parsable};
    use crate::recursive::RecursiveParser;
    use crate::one_of_last;
    use syn::buffer::TokenBuffer;
    use proc_macro2::Ident;

    /// A tree structure for holding parsed identifiers.
    /// Each node has an identifier and an optional pointer (Rc) to the next node.
    #[derive(Debug, Clone)]
    struct IdentList {
        ident: Ident,
        next: Option<Rc<IdentList>>,
    }

    // We want our final output type to be Rc<IdentList>.
    // Implement Parsable for Rc<IdentList> so that every cached combinator
    // is expected to produce that type.
    impl Parsable for Rc<IdentList> {
        type Output<'a> = Rc<IdentList>;
    }

    #[test]
    fn list_parser_with_error_recovery() {
        // -----------------------------------------------------------
        // 1) HAPPY BRANCH: Recursive parser for a comma‐separated list
        // -----------------------------------------------------------
        // Grammar: list = ident [ ',' list ]?
        // Final output type: Rc<IdentList>

        // (a) Create a RecursiveParser that will eventually return Rc<IdentList>.
        let recursive_parser: RecursiveParser<Rc<IdentList>> = RecursiveParser::new();
        let recursive_debug = crate::multi::DebugComb::new("main_recursive", recursive_parser);
        // Wrap the recursive parser in a CachedComb (cache key 0).
        let cached_list_parser =CachedComb::new(recursive_debug, 0, "ident_list recursion");

        // (b) Define the recursive rule.
        // We parse an identifier, then optionally a comma and a recursive call.
        // The Maybe branch returns Option<(proc_macro2::Punct, Rc<IdentList>)>.
        // We map that result to produce an Rc<IdentList>.
        let list_rule = crate::multi::DebugComb::new(
            "list_rule",
            Pair::new(
                crate::multi::DebugComb::new("parse_ident", IdentParser),
                // Use Maybe directly; do not wrap this branch in its own CachedComb.
                Maybe::new(
                    Pair::new(SpecificPunct(','), cached_list_parser.as_ref())
                )
            )
        )
        .map(|(id, maybe_tail)| {
            let next = maybe_tail.map(|(_, tail)| tail);
            Rc::new(IdentList { ident: id, next })
        });
    
        // (c) Initialize the recursive parser with the rule.
        cached_list_parser.inner.inner.set(&list_rule);
    
        // (d) Enforce full input consumption by pairing with IsEOF.
        let happy_branch = crate::multi::DebugComb::new(
            "happy_branch",
            Pair::new(
                cached_list_parser.as_ref(),
                crate::multi::DebugComb::new("check_eof", IsEOF)
            )
            .map(|(tree, _)| tree)
        );
    
        // -----------------------------------------------------------
        // 2) ERROR RECOVERY BRANCH
        // -----------------------------------------------------------
        //
        // When the happy branch fails (for example, when an integer appears),
        // we want to produce an aggregated diagnostic error.
    
        // diagnostic_inner: use ParseReport over ImproveError+ParseForbiden so that if IdentParser fails,
        // an integer is flagged with "forbidden integer usage".
        let diagnostic_inner = crate::multi::DebugComb::new(
            "diagnostic_inner",
            ParseReport::new(
                ImproveError::new(
                    IdentParser,
                    ParseForbiden::<_, _, Rc<IdentList>>::new(IntParser, "forbidden integer usage")
                )
            )
        );
    
        // skip_bad: consume tokens until a comma or EOF is reached.
        let skip_bad = crate::multi::DebugComb::new(
            "skip_bad",
            SkipToEnd::new(
                SpecificPunct(',')
            )
        );
    
        // Combine diagnostic_inner with skip_bad.
        let diagnostic_branch = crate::multi::DebugComb::new(
            "diagnostic_branch",
            Pair::new(diagnostic_inner, skip_bad)
            .map(|(diag, _)| diag)
        );
    
        // skip_good: always consume at least one token.
        // Try to ignore a valid identifier; if that fails, ignore any token.
        let skip_good = crate::multi::DebugComb::new(
            "skip_good",
            one_of_last!(
                Ignore::new(IdentParser),
                Ignore::new(AnyParser)
            )
        );
    
        // recovery_element: skip_good, then diagnostic_branch, then skip_good.
        let recovery_element = crate::multi::DebugComb::new(
            "recovery_element",
            Pair::new(
                skip_good.as_ref(),
                Pair::new(diagnostic_branch, skip_good.as_ref())
            )
            .map(|(_left, (err, _right))| err)
        );
    
        // aggregated_recovery: gather one or more recovery elements into a MultiError.
        let aggregated_recovery = crate::multi::DebugComb::new(
            "aggregated_recovery",
            MultiError::new(Many1::new(recovery_element))
        );
    
        // -----------------------------------------------------------
        // 3) UNIFIED PARSER: Combine HAPPY and ERROR branches.
        // -----------------------------------------------------------
        //
        // Instead of a custom closure, we use ImproveError to try happy_branch first.
        // If happy_branch fails, it runs aggregated_recovery and replaces the error.
        let unified_parser = crate::multi::DebugComb::new(
            "unified_parser",
            ImproveError::new(happy_branch, aggregated_recovery)
        );

        // -----------------------------------------------------------
        // 4) RUN TESTS
        // -----------------------------------------------------------
    
        // Create a cache of size 3 (all cached combinators produce Rc<IdentList>).
        let mut cache: BasicCache<3, Rc<IdentList>> = BasicCache::new();
    
        // VALID INPUT: "a, b, c"
        let valid_input_str = "a, b, c";
        let tokens_valid = valid_input_str.parse().expect("Tokenization failed");
        let buffer_valid = TokenBuffer::new2(tokens_valid);
        let input_valid = Input::new(&buffer_valid);
    
        match unified_parser.parse(input_valid, &mut cache) {
            Ok((remaining, tree)) => {
                assert!(remaining.eof());
                println!("Parsed IdentList (valid): {:#?}", tree);
            }
            Err(e) => panic!("Expected success, got error: {}", e.inner()),
        }
    
        // INVALID INPUT: "a, 123, c d, b,,"
        let invalid_input_str = "a, 123, c d, b,,";
        let tokens_invalid = invalid_input_str.parse().expect("Tokenization failed");
        let buffer_invalid = TokenBuffer::new2(tokens_invalid);
        let input_invalid = Input::new(&buffer_invalid);
        let mut cache2: BasicCache<3, Rc<IdentList>> = BasicCache::new();
    
        match unified_parser.parse(input_invalid, &mut cache2) {
            Ok((_, tree)) => {
                panic!("Expected error recovery, but parsed: {:#?}", tree);
            }
            Err(PakeratError::Regular(err)) => {
                println!("Got aggregated error (expected): {}", err);
            }
            Err(PakeratError::Recursive(err)) => panic!("Unexpected error variant: {}", err),
        }

        // INVALID INPUT:
        let invalid_input_str = ",,,,,";
        let tokens_invalid = invalid_input_str.parse().expect("Tokenization failed");
        let buffer_invalid = TokenBuffer::new2(tokens_invalid);
        let input_invalid = Input::new(&buffer_invalid);
        let mut cache2: BasicCache<3, Rc<IdentList>> = BasicCache::new();
    
        match unified_parser.parse(input_invalid, &mut cache2) {
            Ok((_, tree)) => {
                panic!("Expected error recovery, but parsed: {:#?}", tree);
            }
            Err(PakeratError::Regular(err)) => {
                println!("Got aggregated error (expected): {}", err);
            }
            Err(PakeratError::Recursive(err)) => panic!("Unexpected error variant: {}", err),
        }

        // INVALID INPUT:
        let invalid_input_str = "a a,123";
        let tokens_invalid = invalid_input_str.parse().expect("Tokenization failed");
        let buffer_invalid = TokenBuffer::new2(tokens_invalid);
        let input_invalid = Input::new(&buffer_invalid);
        let mut cache2: BasicCache<3, Rc<IdentList>> = BasicCache::new();
    
        match unified_parser.parse(input_invalid, &mut cache2) {
            Ok((_, tree)) => {
                panic!("Expected error recovery, but parsed: {:#?}", tree);
            }
            Err(PakeratError::Regular(err)) => {
                println!("Got aggregated error (expected): {}", err);
            }
            Err(PakeratError::Recursive(err)) => panic!("Unexpected error variant: {}", err),
        }
    }
}


#[cfg(test)]
mod ident_list_tests {
    use crate::recursive::RecursiveParser;
use crate::reporting::Parsable;
use std::rc::Rc;
    use crate::basic_parsers::{IdentParser, SpecificPunct};
    use crate::cache::{BasicCache, CachedComb};
    use crate::combinator::{Combinator, CombinatorExt, PakeratError};
    use crate::core::Input;
    use crate::multi::{Maybe, Pair};
    
    
    use syn::buffer::TokenBuffer;
    use proc_macro2::Ident;

    /// A tree structure to hold parsed identifiers.
    ///
    /// Each node contains an identifier and an optional pointer (Rc) to the next element.
    #[derive(Debug)]
    #[allow(dead_code)]
    struct IdentList {
        ident: Ident,
        next: Option<Rc<IdentList>>,
    }

    impl Parsable for IdentList{

        type Output<'a> = IdentList;
    }

    #[test]
    fn ident_list_parser_test() {
        // Example input: a comma-separated list of identifiers.
        let input_str = "a, b, c";
        let tokens = input_str.parse().expect("Tokenization failed");
        let buffer = TokenBuffer::new2(tokens);
        let input = Input::new(&buffer);

        // Create an owned recursive parser.
        let list_parser = CachedComb::new(RecursiveParser::new(),
            0, // Cache key for this recursive rule.
            "ident_list recursion"
        );

        // Define the recursive rule:
        //     list = ident [ ',' list ]?
        // The rule returns an Rc<IdentList>.
        let list_rule = 
            Pair::new(
                IdentParser,
                Maybe::new(
                    Pair::new(SpecificPunct(','), list_parser.as_ref())
                )
            )
            .map(|(id, maybe_tail)| {
                let next = maybe_tail.map(|(_, tail)| tail);
                Rc::new(IdentList { ident: id, next })
            });
            


        // Initialize the recursive parser with the rule.
        list_parser.inner.set(&list_rule);

        // Create a cache with at least one slot.
        let mut cache = BasicCache::<1, Rc<IdentList>>::new();

        // Parse the input.
        match list_parser.parse(input, &mut cache) {
            Ok((remaining, list)) => {
                assert!(remaining.eof());
                println!("Parsed IdentList:\n{:#?}", list);
            }
            Err(PakeratError::Regular(err)) => {
                panic!("Parsing error: {:?}", err);
            }
            Err(e) => panic!("Unexpected error: {:?}", e),
        }
    }
}
